---
layout:     post
title:      "C3线性化算法与 MRO"
subtitle:   "理解Python中的多继承"
date:       2016-4-27
author:     "YuanBao"
header-img: "img/post-python2.jpg"
header-mask: 0.2
catalog: true
tags:
 - python
 - programming
---

> Python 中的方法解析顺序（Method Resolution Order, MRO）定义了多继承存在时 Python 解释器查找函数解析的正确方式。当 Python 版本从 2.2 发展到 2.3 再到现在的 Python 3，MRO算法也随之发生了相应的变化。这种变化在很多时候影响了我们使用不同版本 Python 编程的过程。


## 什么是MRO

MRO 全称方法解析顺序（Method Resolution Order）。它定义了 Python 中多继承存在的情况下，解释器查找函数解析的具体顺序。什么是函数解析顺序？我们首先用一个简单的例子来说明。

![Compiler vs Interpretor](/img/inherit1.png){: width="260px" height="100px" }

上面的类继承图由以下代码所定义：

```python
class A():
    def who_am_i(self):
        print("I am A")
        
class B(A):
    pass
        
class C(A):
    def who_am_i(self):
        print("I am C")

class D(B,C):
    pass
    
d = D()
```

如果我问在 Python 2 中使用D的实例调用 `d.who_am_i()` 时，究竟执行的是 A 中的 `who_am_i()` 还是 C 中的 `who_am_i()`，我想百分之九十以上的人都会不假思索地回答：肯定是 C 中的 `who_am_i()`，因为 C 是 D 的直接父类。然而，如果你把代码用 Python 2 运行一下就可以看到 `d.who_am_i()` 打印的是 `I am A`。

是不是觉得很混乱很奇怪？那么我们继续给一个更混乱的例子，想想如下的代码在 python 2 中的打印结果是什么：

```python
class Base(object):
    def __init__(self):
        print('Base.__init__')

class A(Base):
    def __init__(self):
        super().__init__()
        print('A.__init__')

class B(Base):
    def __init__(self):
        super().__init__()
        print('B.__init__')

class C(A,B):
    def __init__(self):
        super().__init__()
        print('C.__init__')
        
c = C()
```
如果你不能在运行之前百分百的确定你的答案，那么你就是这篇文章的目标。

上述的两个例子展示了 MRO 的作用：**决定基类中的函数到底应该以什么样的顺序调用父类中的函数**。可以明确地说，Python 发展到现在，MRO 算法已经不是一个凭借着执行结果就能猜出来的算法了。如果没有深入到 MRO 算法的细节，稍微复杂一点的继承关系和方法调用都能彻底绕晕你。

## New-style Class vs. Old-style Class

在介绍不同版本的 MRO 算法之前，我们有必要简单地回顾一下 Python 中类定义方式的发展历史。尽管在 Python 3 中已经废除了老式的类定义方式和 MRO 算法，但对于仍然广泛使用的 Python 2 来说，不同的类定义方式与 MRO 算法之间具有紧密的联系。了解这一点将帮助我们从 Python 2 向 Python 3 迁移时不会出现莫名其妙地错误。

在 Python 2.1 及以前，我们定义一个类的时候往往是这个样子（我们把这种类称为 old-style class)：

```python
class A:
    def __init__(self):
        pass
```

Python 2.2 引入了新的模型对象（new-style class），其建议新的类型通过如下方式定义：

```python
class A(object):
    def __init__(self):
        pass
```

**注意后一种定义方式显示注明类 A 继承自 `object`**。Python 2.3 及后续版本为了保持向下兼容，同时提供以上两种类定义用以区分 old-style class 和 new-style class。Python 3 则完全废弃了 old-style class 的概念，不论你通过以上哪种方式书写代码，Python 3 都将明确认为类 A 继承自 `object`。这里我们只是引入 old-style 和 new-style 的概念，如果你对他们的区别感兴趣，可以自行看 [stackoverflow 上有关该问题的解释](http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python)。

## 理解old-style class的 MRO



## C3线性化算法