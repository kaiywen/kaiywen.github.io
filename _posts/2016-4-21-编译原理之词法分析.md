---
layout:     post
title:      "Compiler之词法分析"
subtitle:   "斯坦福编译器课程笔记"
date:       2016-4-19
author:     "YuanBao"
header-img: "img/post-compiler.jpeg"
header-mask: 0.25
catalog: true
tags:
 - compiler
---

>程序设计语言是向人和计算机描述计算过程的记号。如我们所知，这个世界依赖于程序设计语言，因为在所有计算机上运行的所有软件都是用某种程序设计语言所编写。但是，在一个程序可以运行之前，它首先需要被翻译成一种能够被计算机识别的形式。
>
>完成这项翻译工作的软件系统被称为**编译器**。

## 编译型语言 VS 解释型语言

尽管在任何一门有关编译原理的课程上都会提到编译和解释的概念，但是不是每个人都能清除地说明白这两者之间的区别。下图从用户的角度给出了编译器和解释器处理用户程序的基本过程。

![Compiler vs Interpretor](/img/compiler_vs.png){: width="360px" height="260px" }

* **编译器**读取用户使用某种语言编写的<font color="#ff3385"> 源程序 </font>，并把改程序翻译成为一个等价的，用另一种语言编写的<font color="#ff3385"> 目标程序 </font>，用户可以给定数据，并调用目标程序产生输出。
* **解释器**并不通过翻译的方式生成目标程序。从用户的角度来看，解释器直接利用用户提供的输入来执行源程序文件中指定的操作。

按照上面的定义，我们通常所用的Python是一种解释性语言，但事实上Python兼具了编译和解释的过程。一个Python程序首先被编译成为Python字节码，然后通过Python虚拟机解释执行。

## 编译的过程

对于用户来讲，编译器成为了源语言和目标语言之间的黑盒子。如果我们把这个黑盒子揭开，可以看到编译器内部按照顺序完成了下图中的七个步骤：
![Lex](/img/compiler_proc.png){: width="450px" height="300px" }

这七个步骤可以分为两个部分，上面四个步骤我们可以称为*分析*，也就是通常所说的<font color="#ff3385">编译器前端</font>，后面三个步骤则称为*综合*，也就是<font color="#ff3385">编译器的后端</font>。

编译器的前端把源文件分解称为多个组成要素，并在这个要素之间添加上语法结构，之后生成一个该源程序的中间表示。至于这个中间表示，可以是一种抽象的语言描述，也可以是一种其他语言（早期的C++编译器前端就直接将C语言作为中间表示）。

从这个简单的描述可知，我们平时编程中所出现的打字错误，语法错误或者语义不一致等将都由编译器前端负责检查。**另外需要注意的是，上图中忽略了一个非常重要的内容---符号表**，事实上前端会收集代码中的各种组成信息并将其存入到符号表中。符号表和中间表示将一同送入到编译器后端。

后端首先将接收到的中间形式进行机器无关优化，然后根据符号表和中间表示形式生成最终的目标机器代码。一般现代编译器还需要对目标机器代码进行平台相关优化，之后我们才能得到最终的目标代码。

在编译器的前后端架构调整方面，Apple是一个很好地例子。MAC OS从诞生到现在，一共产生过三种针对C-like语言的编译器模型。这三种模型如下表：

|   Compiler       |      front-end         |   optimizer    |    generator   |
|:----------------:|:----------------------:|:--------------:|:--------------:|
| **GCC**      | <font color="#0b78c1">GCC front-end </font> | <font color="#0b78c1">GCC optimizer </font> | <font color="#0b78c1">GCC code-generator</font> |
| **llvm-gcc** | <font color="#0b78c1">GCC front-end </font> | <font color="#1e9680">LLVM optimizer </font> | <font color="#1e9680">LLVM code-generator</font> |
| **Clang**    | <font color="#1e9680">llvm front-end </font> |  <font color="#1e9680">LLVM optimizer </font> | <font color="#1e9680">LLVM code-generator</font> |

实际上，Apple进行这样的调整是为了实现一个易于调试，代码生成质量高，编译速度快的编译器。这个例子也充分的说明了将编译器划分为前端和后端的好处：**通过降低前端和后端的耦合度，从而方便地实现编译器的扩展升级和自由配置**。

## 词法分析

![Lex](/img/lex.png){: width="400px" height="200px" }